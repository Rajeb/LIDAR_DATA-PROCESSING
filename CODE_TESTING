
### Creating square around points
def sq_buffer(x,y,sq_len):
    if type(x) == float:
        xl = x-sq_len/2
        xu = x+sq_len/2
        yl = y-sq_len/2
        yu = y+sq_len/2
        res = (xl,xu,yl,yu)
    else:
        res = []
        for a,b in zip(x,y):
            xl = a-sq_len/2
            xu = a+sq_len/2
            yl = b-sq_len/2
            yu = b+sq_len/2            
            res.append((xl,xu,yl,yu))
    return res


def extract_shape_cp(pointcloud, x, y ,sq_len, geom_buff = 'Circle', buff_radius = 10 , crs = "EPSG:6418"):
    '''
    buff_radius in feet !!! (since point clouds are in feet)
    '''
    
    
    #Extracting square shape from point cloud 
    (xl,xu,yl,yu) = sq_buffer(x,y,sq_len)
    mask_x = (pointcloud[:,0] > xl) & (pointcloud[:,0] < xu)
    mask_y = (pointcloud[:,1] > yl) & (pointcloud[:,1] < yu)
    sub_ix = np.where(mask_x & mask_y)
    sub_sq = pointcloud[sub_ix,:]
    sub_sq = np.squeeze(sub_sq)
    
    #Extracting given shape (geom_buff) from square shape
    gdf_sub = pd.DataFrame({'x':sub_sq[:,0],'y':sub_sq[:,1],'ix':sub_ix[0]})
    gdf_sub = gpd.GeoDataFrame(gdf_sub, geometry=gpd.points_from_xy(gdf_sub.x, gdf_sub.y), crs=crs)
    
    if geom_buff == 'Circle':
        circle_buff = gdf_sub.geometry.buffer(buff_radius)
        mask = gdf_sub.geometry.within(circle_buff)
        sub_shape = pointcloud[gdf_sub.ix[mask],:]
    else:
        if type(geom_buff) == str:
            geom_buff = shapely.wkt.loads(geom_buff)
        
        mask = gdf_sub.geometry.within(geom_buff)
        sub_shape = pointcloud[gdf_sub.ix[mask],:]
    
    return sub_shape
###########

import boto3
import laspy
import geopandas as gpd
from shapely.geometry import box
from pyproj import Transformer
import pandas as pd

# S3 client setup
s3 = boto3.client('s3')

# List .laz files in the bucket
response = s3.list_objects_v2(Bucket=bucket_name, Prefix=file_path)
laz_files = [content['Key'] for content in response.get('Contents', []) if content['Key'].endswith('.laz')]
selected_files = laz_files[:50]  # Select first 50 files

# Function to extract bounding box from .laz files
def get_laz_bounds(file_path, target_crs="EPSG:4326"):
    with laspy.open(file_path) as las:
        header = las.header
        xmin, ymin, zmin = header.mins
        xmax, ymax, zmax = header.maxs
        
        # Transform coordinates to target CRS
        source_crs = "EPSG:6416"
        transformer = Transformer.from_crs(source_crs, target_crs, always_xy=True)
        xmin, ymin = transformer.transform(xmin, ymin)
        xmax, ymax = transformer.transform(xmax, ymax)
        
        return {'xmin': xmin, 'xmax': xmax, 'ymin': ymin, 'ymax': ymax}

# Extract bounding boxes for selected .laz files
laz_bounds = {}
for laz_file in selected_files:
    local_path = f"/tmp/{laz_file.split('/')[-1]}"
    s3.download_file(bucket_name, laz_file, local_path)
    laz_bounds[laz_file] = get_laz_bounds(local_path)

# Convert bounding boxes to GeoDataFrame
laz_df = pd.DataFrame.from_dict(laz_bounds, orient='index').reset_index()
laz_df.columns = ['file', 'xmin', 'xmax', 'ymin', 'ymax']
gdf_laz = gpd.GeoDataFrame(
    laz_df,
    geometry=[box(row['xmin'], row['ymin'], row['xmax'], row['ymax']) for _, row in laz_df.iterrows()],
    crs="EPSG:4326"
)

# Load structure data
clean_structure = pd.read_csv(r"/data/transmission/WTRM/asset_structure/clean_structure.csv", low_memory=False)
gdf_structure = gpd.GeoDataFrame(
    clean_structure,
    geometry=gpd.points_from_xy(clean_structure["longitude"], clean_structure["latitude"]),
    crs="EPSG:4326"
)

# Debug: Print CRS and sample data
print(f"CRS of structure GeoDataFrame: {gdf_structure.crs}")
print(f"CRS of LAZ GeoDataFrame: {gdf_laz.crs}")

# Perform spatial join
result = gpd.sjoin(gdf_structure, gdf_laz, how='inner', predicate='within')

# Debugging: Check results
print(f"Number of matching geometries: {len(result)}")
print(result)







########################################
Extracting for a structure

import laspy
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Specify the structure number
structure_no = "A"

# Filter the result DataFrame for the specific structure
filtered_result = result[result['structure_no'] == structure_no]

if filtered_result.empty:
    print(f"No associated .laz file found for structure {structure_no}")
else:
    # Extract the .laz file associated with the structure
    laz_file = filtered_result['file'].iloc[0]  # Assuming one file per structure

    print(f"Processing .laz file: {laz_file} for structure {structure_no}")
    
    # Function to plot the point cloud
    def plot_point_cloud(laz_file):
        # Download the .laz file from S3
        local_path = f"/tmp/{laz_file.split('/')[-1]}"
        s3.download_file(bucket_name, laz_file, local_path)
        
        # Read the .laz file
        with laspy.open(local_path) as las:
            points = las.read()
            x, y, z = points.x, points.y, points.z  # Extract coordinates
        
        # Plot the point cloud
        fig = plt.figure(figsize=(12, 8))
        ax = fig.add_subplot(111, projection='3d')
        ax.scatter(x, y, z, c=z, cmap='viridis', s=0.1)
        ax.set_title(f"Point Cloud: {laz_file} for Structure {structure_no}")
        ax.set_xlabel("X")
        ax.set_ylabel("Y")
        ax.set_zlabel("Z")
        plt.show()
    
    # Plot the point cloud for the selected file
    plot_point_cloud(laz_file)

